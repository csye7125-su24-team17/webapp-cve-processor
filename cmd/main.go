package main

import (
	"archive/zip"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"github.com/csye7125-su24-team17/webapp/pkg"
)

// downloadFile downloads a file from the specified URL and saves it to the specified destination
func downloadFile(url string, folder string, filename string) error {
	if err := os.MkdirAll(folder, os.ModePerm); err != nil {
		fmt.Printf("failed to create folder: %v", err)
  }
	resp, err := http.Get(url)
  if err != nil {
    return fmt.Errorf("failed to download file: %v", err)
  }
  defer resp.Body.Close()

	filePath := filepath.Join(folder, filename)
  file, err := os.Create(filePath)
  if err != nil {
    return fmt.Errorf("failed to create file: %v", err)
  }
  defer file.Close()

	_, err = io.Copy(file, resp.Body)
  if err != nil {
    return fmt.Errorf("failed to save file: %v", err)
  }

  return nil
}

// unzipFile extracts the contents of the zip file to the specified destination
func unzipFile(zipPath string, destDir string) error {
	// Open the ZIP file specified by zipPath.
	r, err := zip.OpenReader(zipPath)
	if err != nil {
		return err // Return an error if the ZIP file can't be opened.
	}
	defer r.Close() // Ensure the ZIP file is closed when the function exits.

	// Create a WaitGroup to wait for all goroutines to complete.
	var wg sync.WaitGroup

	// Create a buffered channel to limit the number of concurrent extractions.
	maxGoroutines := runtime.NumCPU() // Use the number of CPU cores
	semaphore := make(chan struct{}, maxGoroutines)

	// Iterate over each file and directory in the ZIP archive.
	for _, file := range r.File {
		// Skip delta.json and deltaLog.json files
		if file.Name == "delta.json" || file.Name == "deltaLog.json" {
			log.Printf("Skipping file: %s", file.Name)
			continue
		}

		wg.Add(1) // Increment the WaitGroup counter

		// Launch a goroutine to extract the file.
		go func(file *zip.File) {
			defer wg.Done() // Decrement the counter when the goroutine completes

			// Use the semaphore to limit the number of concurrent goroutines.
			semaphore <- struct{}{}
			defer func() { <-semaphore }() // Release the semaphore slot when done

			// Construct the full file path where the file or directory should be extracted.
			filePath := filepath.Join(destDir, file.Name)

			// Check if the current item is a directory.
			if file.FileInfo().IsDir() {
				// If it's a directory, create the directory and any necessary parent directories.
				os.MkdirAll(filePath, os.ModePerm)
			} else {
				// If it's a file, ensure the parent directory exists.
				os.MkdirAll(filepath.Dir(filePath), os.ModePerm)

				// Create the file where the content will be extracted.
				outFile, err := os.Create(filePath)
				if err != nil {
					log.Printf("Failed to create file %s: %v", filePath, err)
					return
				}
				defer outFile.Close() // Ensure the file is closed when done

				// Open the file in the ZIP archive for reading.
				rc, err := file.Open()
				if err != nil {
					log.Printf("Failed to open file %s in the ZIP archive: %v", file.Name, err)
					return
				}
				defer rc.Close() // Ensure the ZIP archive's file is closed when done

				// Copy the contents from the ZIP archive's file to the newly created file.
				_, err = io.Copy(outFile, rc)
				if err != nil {
					log.Printf("Failed to copy contents to file %s: %v", filePath, err)
					return
				}
			}
		}(file)
	}

	// Wait for all goroutines to complete.
	wg.Wait()
	return nil // Return nil to indicate successful extraction.
}

func main() {
	zipURL, ok := os.LookupEnv("zip_url")
	if !ok {
		zipURL =  "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
	}
	zipName := path.Base(zipURL)
	downloadPath := "downloads"

	log.Println("Downloading ZIP file...")
	if err := downloadFile(zipURL, downloadPath, zipName); err != nil {
		log.Fatalf("Failed to download file: %v", err)
	}

	// Step 2: Unzip the downloaded file
	log.Println("Extracting ZIP file...")
	zipPath := filepath.Join(downloadPath, zipName)
	extractDir := filepath.Join(downloadPath, strings.TrimSuffix(zipName, ".zip"))
	if err := unzipFile(zipPath, extractDir); err != nil {
		log.Fatalf("Failed to unzip file: %v", err)
	}

	log.Println("Processing CVE files...")
	root := ""
	if extractDir == filepath.Join("downloads", "main") {
		root = filepath.Join(strings.TrimSuffix(zipPath, ".zip"), filepath.Join("cvelistV5-main", "cves"))
	}else{
		root = filepath.Join(extractDir, "deltaCves")
	}
	pkg.PushToKafka(root)

	log.Println("Cleaning up...")
	os.RemoveAll(downloadPath)
}
