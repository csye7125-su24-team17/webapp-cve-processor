package main

import (
	"archive/zip"
	"database/sql"
	// "fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"sync"

	"github.com/csye7125-su24-team17/webapp/pkg"

	// "github.com/joho/godotenv"

	_ "github.com/lib/pq" // Importing the PostgreSQL driver package
)

// downloadFile downloads a file from the specified URL and saves it to the specified destination
func downloadFile(url string, dest string) error {
	// Create the file
	out, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer out.Close()

	// Download the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Write the data to the file
	_, err = io.Copy(out, resp.Body)
	return err
}

// unzipFile extracts the contents of the zip file to the specified destination
func unzipFile(zipPath string, destDir string) error {
	// Open the ZIP file specified by zipPath.
	r, err := zip.OpenReader(zipPath)
	if err != nil {
		return err // Return an error if the ZIP file can't be opened.
	}
	defer r.Close() // Ensure the ZIP file is closed when the function exits.

	// Create a WaitGroup to wait for all goroutines to complete.
	var wg sync.WaitGroup

	// Create a buffered channel to limit the number of concurrent extractions.
	maxGoroutines := runtime.NumCPU() // Use the number of CPU cores
	semaphore := make(chan struct{}, maxGoroutines)

	// Iterate over each file and directory in the ZIP archive.
	for _, file := range r.File {
		// Skip delta.json and deltaLog.json files
		if file.Name == "delta.json" || file.Name == "deltaLog.json" {
			log.Printf("Skipping file: %s", file.Name)
			continue
		}

		wg.Add(1) // Increment the WaitGroup counter

		// Launch a goroutine to extract the file.
		go func(file *zip.File) {
			defer wg.Done() // Decrement the counter when the goroutine completes

			// Use the semaphore to limit the number of concurrent goroutines.
			semaphore <- struct{}{}
			defer func() { <-semaphore }() // Release the semaphore slot when done

			// Construct the full file path where the file or directory should be extracted.
			filePath := filepath.Join(destDir, file.Name)

			// Check if the current item is a directory.
			if file.FileInfo().IsDir() {
				// If it's a directory, create the directory and any necessary parent directories.
				os.MkdirAll(filePath, os.ModePerm)
			} else {
				// If it's a file, ensure the parent directory exists.
				os.MkdirAll(filepath.Dir(filePath), os.ModePerm)

				// Create the file where the content will be extracted.
				outFile, err := os.Create(filePath)
				if err != nil {
					log.Printf("Failed to create file %s: %v", filePath, err)
					return
				}
				defer outFile.Close() // Ensure the file is closed when done

				// Open the file in the ZIP archive for reading.
				rc, err := file.Open()
				if err != nil {
					log.Printf("Failed to open file %s in the ZIP archive: %v", file.Name, err)
					return
				}
				defer rc.Close() // Ensure the ZIP archive's file is closed when done

				// Copy the contents from the ZIP archive's file to the newly created file.
				_, err = io.Copy(outFile, rc)
				if err != nil {
					log.Printf("Failed to copy contents to file %s: %v", filePath, err)
					return
				}
			}
		}(file)
	}

	// Wait for all goroutines to complete.
	wg.Wait()
	return nil // Return nil to indicate successful extraction.
}

func main() {
	// err := godotenv.Load(".env")
  // if err != nil {
  //   log.Fatalf("Error loading .env file")
  // }
  // db_host := os.Getenv("DB_HOST")
  // db_port := os.Getenv("DB_PORT")
  // db_user := os.Getenv("DB_USER")
  // db_password := os.Getenv("DB_PASSWORD")
  // db_name := os.Getenv("DB_NAME")

	// connStr := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
  //       db_host, db_port, db_name, db_user, db_password)

	// Establish a connection to the PostgreSQL database
	dbConn, err := sql.Open("postgres", "host=host.docker.internal port=5433 dbname=cve user=postgres password=E@s123h@n456 sslmode=disable")
	if err != nil {
		log.Fatal(err)
	}
	defer dbConn.Close()

	// Define the URL of the ZIP file and the local paths
	zipURL := "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
	zipPath := "cvelistV5-main.zip"
	extractDir := "cvelistV5-main"

	// Step 1: Download the ZIP file
	log.Println("Downloading ZIP file...")
	if err := downloadFile(zipURL, zipPath); err != nil {
		log.Fatalf("Failed to download file: %v", err)
	}

	// Step 2: Unzip the downloaded file
	log.Println("Extracting ZIP file...")
	if err := unzipFile(zipPath, extractDir); err != nil {
		log.Fatalf("Failed to unzip file: %v", err)
	}

	// Define the directory containing the CVE JSON files
	root := filepath.Join(extractDir, "cvelistV5-main", "cves")

	// Step 3: Process the CVE files located in the extracted directory
	log.Println("Processing CVE files...")
	pkg.ProcessCVEFiles(dbConn, root)

	// Optional: Clean up the downloaded and extracted files after processing
	log.Println("Cleaning up...")
	os.Remove(zipPath)
	os.RemoveAll(extractDir)
}
