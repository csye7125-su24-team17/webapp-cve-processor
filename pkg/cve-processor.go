package pkg

import (
	"database/sql"
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// The CVE structure should match the expected fields in the JSON files.
type CVE struct {
	CveMetadata struct {
		CveId         string `json:"cveId"`
		DatePublished string `json:"datePublished"`
		DateUpdated   string `json:"dateUpdated"`
		AssignerOrgId string `json:"assignerOrgId"`
	} `json:"cveMetadata"`
	Containers struct {
		Cna interface{} `json:"cna"` // Store the whole CNA container
	} `json:"containers"`
	DataType    string `json:"dataType"`
	DataVersion string `json:"dataVersion"`
}

// ProcessCVEFiles walks through all files in the specified directory and processes each JSON file.
func ProcessCVEFiles(db *sql.DB, rootPath string) {
	err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if filepath.Ext(path) == ".json" { // Only process files with a .json extension
			processFile(db, path)
		}
		return nil
	})
	if err != nil {
		log.Printf("Error walking through CVE directory: %v", err)
	}
}

// processFile reads and processes a single JSON file from the given path.
func processFile(db *sql.DB, path string) {

	// Get the file name
	fileName := filepath.Base(path)

	// Skip delta.json and deltaLog.json files
	if fileName == "delta.json" || fileName == "deltaLog.json" {
		log.Printf("Skipping file: %s", fileName)
		return
	}
	data, err := os.ReadFile(path) // Read the file content
	if err != nil {
		log.Printf("Error reading file %s: %v", path, err)
		return
	}
	var cve CVE
	if err := json.Unmarshal(data, &cve); err != nil { // Unmarshal the JSON content into the CVE struct
		log.Printf("Error unmarshalling JSON from file %s: %v", path, err)
		return
	}
	storeCVE(db, &cve, data) // Store the CVE data in the database
}

// stripTrailingZ removes the trailing 'Z' from a date string if it exists
// This is useful for normalizing date formats before comparison.
func stripTrailingZ(dateStr string) string {
	return strings.TrimSuffix(dateStr, "Z")
}

// storeCVE stores the CVE data in the database with versioning support.
func storeCVE(db *sql.DB, cve *CVE, jsonData []byte) {
	var currentVersion int
	var latestData []byte
	var latestDateUpdated string

	// Fetch the latest version, data, and dateUpdated of the CVE record from the database
	err := db.QueryRow(`
		SELECT version, data, date_updated 
		FROM cve.cve_records 
		WHERE cve_id = $1 
		ORDER BY version DESC LIMIT 1`,
		cve.CveMetadata.CveId).Scan(&currentVersion, &latestData, &latestDateUpdated)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("Error fetching latest version for CVE %s: %v", cve.CveMetadata.CveId, err)
		return
	}

	// Strip the trailing 'Z' from both dates if present
	strippedLatestDateUpdated := stripTrailingZ(latestDateUpdated)
	strippedIncomingDateUpdated := stripTrailingZ(cve.CveMetadata.DateUpdated)

	// Compare the stripped `dateUpdated` values
	if strippedIncomingDateUpdated == strippedLatestDateUpdated {
		// log.Printf("No changes detected for CVE %s based on `dateUpdated`; skipping update.", cve.CveMetadata.CveId)
		return
	}

	// Increment the version for the new data
	newVersion := currentVersion + 1

	// Optional: Extract additional fields such as severity scores from the JSON
	severityScores := ""
	if s, ok := cve.Containers.Cna.(map[string]interface{})["severityScores"].(string); ok {
		severityScores = s
	}

	// Insert the new version of the CVE record
	_, err = db.Exec(`
		INSERT INTO cve.cve_records (cve_id, data, date_published, date_updated, version, severity_scores)
		VALUES ($1, $2, $3, $4, $5, $6)
		ON CONFLICT (cve_id, version) DO UPDATE
		SET data = EXCLUDED.data, date_updated = EXCLUDED.date_updated, updated_at = NOW(), severity_scores = EXCLUDED.severity_scores`,
		cve.CveMetadata.CveId, jsonData, cve.CveMetadata.DatePublished, cve.CveMetadata.DateUpdated, newVersion, severityScores)
	if err != nil {
		log.Printf("Failed to store/update CVE in database: %v", err)
	}
}
